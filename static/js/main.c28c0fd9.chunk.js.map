{"version":3,"sources":["logo.svg","Components/ChannelTimeslot.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","React","Component","HOUR_PX","window","innerWidth","StreamerContext","createContext","TimeContext","UserContext","TimelineHeaderLabel","props","context","useContext","handleClick","setTime","time","subtract","style","width","index","hours","minutes","className","onClick","format","TimelineHeader","time_clone","moment","start","hours_arr","a","b","push","add","key","TimelineStreamLineRender","streams_arr","streams","stream","start_x","duration","start_time","diff","asMinutes","end_time","left","src","profile_picture","fill","color","height","setUser","name","description","cx","cy","r","x","y","dominant-baseline","text-anchor","TimelineStreamRender","groups","grouped_streams","length","TimelineCategory","grouped","stream_to_be_sorted","splice","stream_sorted","saved","isAfter","isBefore","groupStreams","backgroundColor","StreamerInfo","component","href","auth_string","username","user","targetClass","channel","layout","TimeLineBody","useState","streamers","valid","start_of_week","startOf","range_end_moment","looking_for_end","data","forEach","profile","desc","current_start","undefined","schedule","streamer","day","filter","Provider","value","twitch_get","endpoint","access_token","client_id","headers","fetch","If","this","condition","children","Loader","App","streamer_data","setStreamerData","current_user","setCurrentUser","api_url","claims","JSON","stringify","userinfo","email","email_verified","picture","preferred_username","useEffect","location","hash","raw_auth_data","slice","split","map","auth_data","id_token","scope","token_type","json","sub","console","log","d","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.c28c0fd9.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/logo.ee7cd8ed.svg\";","import React from 'react';\r\nimport Carousel from \"react-spring-3d-carousel\"\r\nimport uuidv4 from \"uuid\";\r\n\r\nclass Timeslot extends React.Component {\r\n   state = {\r\n    goToSlide: 0,\r\n    offsetRadius: 2,\r\n    showNavigation: true,\r\n  };\r\n\r\n    slides = [\r\n    {\r\n      key: uuidv4(),\r\n      content: <img src=\"https://picsum.photos/800/800/?random\" alt=\"1\" />\r\n    },\r\n    {\r\n      key: uuidv4(),\r\n      content: <img src=\"https://picsum.photos/800/800/?random\" alt=\"2\" />\r\n    },\r\n    {\r\n      key: uuidv4(),\r\n      content: <img src=\"https://picsum.photos/600/800/?random\" alt=\"3\" />\r\n    },\r\n    {\r\n      key: uuidv4(),\r\n      content: <img src=\"https://picsum.photos/800/500/?random\" alt=\"4\" />\r\n    },\r\n    {\r\n      key: uuidv4(),\r\n      content: <img src=\"https://picsum.photos/800/800/?random\" alt=\"5\" />\r\n    },\r\n    {\r\n      key:uuidv4(), \r\n      content: <img src=\"https://picsum.photos/500/800/?random\" alt=\"6\" />\r\n    },\r\n    {\r\n      key: uuidv4(),\r\n      content: <img src=\"https://picsum.photos/800/600/?random\" alt=\"7\" />\r\n    },\r\n    {\r\n      key: uuidv4(),\r\n      content: <img src=\"https://picsum.photos/800/800/?random\" alt=\"8\" />\r\n    }\r\n  ].map((slide, index) => {\r\n    return { ...slide, onClick: () => this.setState({ goToSlide: index }) };\r\n  });\r\n\r\n\r\n  render() {\r\n    \r\n    return (\r\n      <div style={{\r\n        // Background styling\r\n        backgroundColor: \"red\", \r\n        position: \"absolute\", \r\n        width: \"100%\",\r\n        height: \"100%\",\r\n\r\n\r\n        //Outline styling \r\n        outlineWidth: \"10px\",\r\n        outlineStyle: \"solid\",\r\n        outlineColor: \"blue\",\r\n        outlineOffset: \"-10px\"\r\n        }}>\r\n            <Carousel\r\n                slides={this.slides}\r\n                goToSlide={this.state.goToSlide}\r\n                offsetRadius={this.state.offsetRadius}\r\n            />\r\n        </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Timeslot;","import React, { useState, useContext, useEffect } from 'react';\r\nimport logo from './logo.svg';\r\nimport Timeslot from './Components/ChannelTimeslot.js'\r\nimport 'react-calendar-timeline/lib/Timeline.css'\r\nimport './css/reset.css';\r\nimport './css/App.css';\r\nimport moment from 'moment'\r\nimport Timeline from 'react-calendar-timeline'\r\nimport ReactTwitchEmbedVideo from \"react-twitch-embed-video\"\r\n\r\n\r\nlet HOUR_PX = window.innerWidth/24;\r\nif(HOUR_PX < 70){\r\n  HOUR_PX = 70;\r\n}\r\n\r\nconst StreamerContext = React.createContext({})\r\nconst TimeContext = React.createContext({});\r\nconst UserContext = React.createContext({});\r\n\r\n//Takes a group of streams and produces a non-overlapping grouping of streams to render\r\n//Result is An Array<Array<Streams>>\r\nfunction groupStreams(streams){\r\n  let groups = [];\r\n  let streams_sorted = 0;\r\n  let selected_group = 0;\r\n  \r\n  while(streams.length > 0){\r\n    let stream_to_be_sorted = streams[0];\r\n    streams.splice(0,1);\r\n    let stream_sorted = false;\r\n    //Track to see if the stream fits between any streams that have already been sorted\r\n    for(let a = 0; a < groups.length && !stream_sorted;a++){\r\n      for(let b = 0;b < groups[a].length;b++){\r\n        //Check each group, looking at two streams at a time\r\n        //Check if stream is inbetween those two\r\n        let saved = groups[a][b];\r\n        //Need an exemption for the last, as there is no second stream to check after\r\n        if(b === groups[a].length - 1){\r\n          if(stream_to_be_sorted.start_time.isAfter(moment(saved.end_time).add(1,\"hour\"))){\r\n            stream_sorted = true;\r\n            groups[a].push(stream_to_be_sorted);\r\n            break;\r\n          }\r\n        }\r\n        else{\r\n          //Check if the start time and end time of the stream we are checking is inbetween\r\n          //the end and start time of the two streams we are checking\r\n          if(stream_to_be_sorted.start_time.isAfter(moment(saved.end_time).add(1,\"hour\") && stream_to_be_sorted.end_time.isBefore(moment(groups[a][b+1].start_time)))){\r\n            stream_sorted = true;\r\n            groups[a].push(stream_to_be_sorted);\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    //If the stream didn't fit, create a new group for this stream\r\n    if(!stream_sorted){\r\n      groups.push([])\r\n      groups[groups.length - 1].push(stream_to_be_sorted);\r\n    }\r\n  }\r\n  return groups;\r\n}\r\n\r\n//Generates one element for the timeline header\r\nlet TimelineHeaderLabel = (props)=>{\r\n  const context = useContext(TimeContext);\r\n    let handleClick = () => {\r\n      context.setTime(props.time.subtract(2,\"hours\"));\r\n      //The \"selected\" time, rendered with the purple box, is actually the third index label,\r\n      //This is to allow the user to move backward on the timeline\r\n      //This means we must subtract 2 labels worth of time to have the selected time\r\n      //End up in the purple box\r\n    }\r\n    let style = {width:HOUR_PX};\r\n    if(props.index === 2){\r\n      style[\"backgroundColor\"] = \"purple\";\r\n    }\r\n    if(props.time.hours() === 0 && props.time.minutes() === 0){\r\n      return(\r\n        <div className=\"timeline-header-label timeline-header-label-day\" style={style} onClick={()=>{handleClick()}}>\r\n          <p className=\"timeline-header-day\">{props.time.format(\"M/D\")}</p>\r\n          <p>{props.time.format(\"h:mm a\")}</p>\r\n        </div>\r\n      )\r\n    } else {\r\n      return(<div className=\"timeline-header-label\" style={style} onClick={()=>{handleClick()}}>\r\n        <p>{props.time.format(\"h:mm\")}</p>\r\n        <p>{props.time.format(\"a\")}</p>\r\n       </div>\r\n      )\r\n    }\r\n}\r\n\r\nfunction TimelineHeader(props){\r\n  let time_clone = moment(props.start);\r\n  //Need to offset the time, because we add 30 minutes everytime \r\n  //We add a new time label\r\n  time_clone.subtract(1,\"hour\");\r\n  let hours_arr = [];\r\n  for(let a = 0,b = 0;a < window.innerWidth; a += HOUR_PX, b++){\r\n    //Continously add new Timeline labels until we cover the screen\r\n    hours_arr.push(\r\n      <TimelineHeaderLabel time={moment(time_clone.add(1,\"hour\"))} index={b} key={b}/>\r\n    )\r\n  }\r\n  return(\r\n    <div className=\"timeline-header-holder\">\r\n      {hours_arr}\r\n    </div>\r\n\r\n  )\r\n}\r\n\r\n\r\n\r\n//Render the lines that represent streams in the timeline body\r\nfunction TimelineStreamLineRender(props){\r\n  const context = useContext(UserContext);\r\n\r\n  let start = moment(props.start);  \r\n  let streams_arr = [];\r\n  let index = 0;\r\n  for(let stream of props.streams){\r\n    let start_x = moment.duration(stream.start_time.diff(start)).asMinutes()/60 * HOUR_PX;\r\n    let duration = moment.duration(stream.end_time.diff(stream.start_time)).asMinutes()/60 * HOUR_PX;\r\n    //These are pixel values that represent the left position of the element, and the\r\n    //duration, which would be the length\r\n    streams_arr.push(\r\n      <div key={index} className=\"time-stream-container\" style={{left:start_x}}>\r\n        <img className=\"time-stream-picture\" src={stream.profile_picture} />\r\n        <svg style={{fill:props.color}} className=\"timeline-stream\" height=\"50\" width={duration+25} onClick={()=>{context.setUser({name:stream.name,description:stream.description})}}>\r\n          <g>\r\n            <circle cx=\"15\" cy=\"25\" r=\"15\"></circle>\r\n            <rect x=\"15\" y=\"17.5\" width={duration} height=\"15\" />\r\n            <text x=\"50%\" y=\"20%\" dominant-baseline=\"middle\" text-anchor=\"middle\">{stream.name}</text> \r\n            <circle cx={duration+10} cy=\"25\" r=\"15\"></circle>\r\n          </g>\r\n        </svg>\r\n      </div>);\r\n      index++;\r\n  }\r\n  return (\r\n    <div className=\"timeline-render-line\">\r\n      {\r\n        streams_arr\r\n      }\r\n    </div>\r\n    );\r\n}\r\n\r\n//Takes the prop grouped_streams, which is the Array<Array<streams>>\r\n//This will render the entire line stream view in the body, under one category\r\nfunction TimelineStreamRender(props) {\r\n  let groups = [];\r\n  for (let a = 0; a < props.grouped_streams.length;a++){\r\n    groups.push(<TimelineStreamLineRender start={props.start} key={a} color={props.color} streams={props.grouped_streams[a]}/>)\r\n  }\r\n  return(<div>\r\n    {groups}\r\n  </div>)\r\n}\r\n\r\n//Takes in a streams prop, representing the ungrouped streams for this category\r\n//and a name prop for the category name, color for the category color\r\n//and a start prop, which is the current selected time as a momentjs object\r\n//Renders an entire category on screen, like FOLLOWERS or a game like JUST CHATTING\r\nfunction TimelineCategory(props){\r\n    if(props.streams.length > 0){\r\n    let grouped = groupStreams(props.streams)\r\n    return(\r\n      <div className=\"category-container\">\r\n        <div style={{color:props.color}} className=\"timeline-category\">\r\n          <div className=\"timeline-category-container\">\r\n            <p className=\"timeline-category-name\">{props.name}</p>\r\n            <div style={{backgroundColor:props.color}} className=\"timeline-category-bar\"></div>\r\n          </div>\r\n          \r\n        </div>\r\n        <div className=\"category-holder\"></div>\r\n        <TimelineStreamRender grouped_streams={grouped} start={props.start} color={props.color} />\r\n      </div>\r\n    )\r\n  }\r\n  return <div></div>;\r\n}\r\n\r\n//Renders the streamer embed, streamer description and login bar\r\nfunction StreamerInfo(props){\r\n  const context = useContext(UserContext);\r\n\r\n  let component = <a className=\"site_login\" href={props.auth_string}>Login With Twitch</a>;\r\n  if(props.username){\r\n    component = <p className=\"site_login\">{props.username} <a className=\"site_logout\" href=\"./\">LOGOUT</a></p>\r\n  }\r\n  return(\r\n    <div className=\"header-bar\">\r\n        <div className=\"header-container\">\r\n          <div className=\"info-box\">\r\n              <p className=\"site_logo\">TWITCH SURFER</p>\r\n              {component}           \r\n            <div className=\"streamer-info\">\r\n              <p className=\"streamer-name\">{context.user.name}</p>\r\n              <div className=\"streamer-desc\">\r\n              <p>{context.user.description}</p>\r\n              </div>\r\n            </div>\r\n\r\n          </div>\r\n          <ReactTwitchEmbedVideo targetClass=\"streamer-embed\" channel={context.user.name} width=\"500px\" height=\"100%\" layout=\"video\" />\r\n        </div>\r\n      </div>\r\n  )\r\n}\r\n\r\nlet TimeLineBody = (props) => {\r\n  \r\n  const [time, setTime] = useState(moment().subtract(1,\"hour\").subtract(moment().minutes(),'minutes'));\r\n  const streamers = useContext(StreamerContext);\r\n  let start = time;\r\n  let streams = [];\r\n  //TODO: Cache this parsing for better performance\r\n  if (streamers.valid) {\r\n    let start_of_week = moment(start).startOf(\"week\");\r\n    let range_start = moment(start).diff(start_of_week, \"minutes\") / 30;\r\n    let range_end_moment = moment(start).add((window.innerWidth / HOUR_PX) * 60, \"minutes\");\r\n    //Moment objects representing the current selected time, and the time range displayed \r\n    //on screen\r\n    let looking_for_end = false;\r\n    //The data is formated as an array of times ranging from 0 - 335\r\n    //The times represent alternating start and end times for streams\r\n    //Every two times = one whole stream\r\n    //We alternate this variable to track whether the next time will be a start or end\r\n    streamers.data.forEach((x) => {\r\n      let profile = \"https://static-cdn.jtvnw.net/jtv_user_pictures/xqcow-profile_image-9298dca608632101-300x300.jpeg\";\r\n      let desc = \"No description given.\";\r\n      if(x.description){\r\n        desc = x.description;\r\n      }\r\n      if(x.profile){\r\n        profile = x.profile;\r\n      }\r\n      let current_start = undefined;\r\n      for (let a = 0; a < x.schedule.length; a++) {\r\n        //If the time is an end time, create a stream object representing it\r\n        //The data we are parsing is generalized for the week, meaning it is \r\n        //not a momentjs object, instead being a time ranging from 0 - 335 that\r\n        //Would be the half hour point relative to the start of the week.\r\n        //The timeline renderer uses exact momentjs object to display, so we \r\n        //make moment objects that represent these times relative to the start of the week\r\n        if (looking_for_end) {\r\n          streams.push({\r\n            name: x.streamer,\r\n            profile_picture: profile,\r\n            description: desc,\r\n            start_time: current_start,\r\n            end_time: moment(start_of_week).add(x.schedule[a] * 30, \"minutes\")\r\n          })\r\n          //We double streams that happen earlier in the week to ensure a smooth transition\r\n          //from week to week. without doubling, streams aren't rendered correctly when going\r\n          //from one week to another\r\n          if(moment(current_start).day() < 4){\r\n            streams.push({\r\n              name: x.streamer,\r\n              profile_picture: profile,\r\n              description: desc,\r\n              start_time: moment(current_start).add(1, \"week\"),\r\n              end_time: moment(start_of_week).add(x.schedule[a] * 30, \"minutes\").add(1,\"week\")\r\n            })\r\n          }\r\n          looking_for_end = false;\r\n        }\r\n        else {\r\n          //This time must be the start of a stream if we aren't looking for an end point\r\n          current_start = moment(start_of_week).add(x.schedule[a] * 30, \"minutes\");\r\n          looking_for_end = true;\r\n        }\r\n      }\r\n      if(looking_for_end){\r\n        streams.push({\r\n          name: x.streamer,\r\n          profile_picture: profile,\r\n          description: desc,\r\n          start_time: moment(start_of_week).add(x.schedule[x.schedule.length - 1] * 30, \"minutes\"),\r\n          end_time: moment(start_of_week).add(336 * 30, \"minutes\")\r\n        })\r\n        if(moment(current_start).day() < 4){\r\n          streams.push({\r\n            name: x.streamer,\r\n            profile_picture: profile,\r\n            description: desc,\r\n            start_time: moment(start_of_week).add(x.schedule[x.schedule.length - 1] * 30, \"minutes\").add(1,\"week\"),\r\n            end_time: moment(start_of_week).add(336 * 30, \"minutes\").add(1,\"week\")\r\n          })\r\n        }\r\n      }\r\n      looking_for_end = false;\r\n    })\r\n    //Filter for streams that are in our viewport\r\n    streams = streams.filter((x) => (x.start_time.isAfter(start) && x.start_time.isBefore(range_end_moment)) || (x.end_time.isAfter(start) && x.end_time.isBefore(range_end_moment)));\r\n  }\r\n  return (\r\n    <TimeContext.Provider value={{ time: time, setTime: setTime }}>\r\n      <div className=\"timeline\">\r\n        <div className=\"timeline-time-labels\">\r\n          <TimelineHeader start={start} />\r\n        </div>\r\n        <div className=\"timeline-body\">\r\n          <TimelineCategory start={start} streams={streams} name=\"FOLLOWING\" color=\"#88fffb\" />\r\n        </div>\r\n      </div>\r\n    </TimeContext.Provider>\r\n  )\r\n} \r\n\r\nfunction twitch_get(endpoint,access_token,client_id){\r\n  let headers = {\r\n    \"Authorization\": `Bearer ${access_token}`,\r\n  };\r\n  if(client_id){\r\n    headers[\"Client-ID\"] = client_id;\r\n  }\r\n  return fetch(endpoint,{ headers:headers });\r\n}\r\n\r\nclass If extends React.Component{\r\n  render(){\r\n    let {condition} = this.props;\r\n    if(condition){\r\n      return this.props.children;\r\n    }\r\n    return (<div></div>);\r\n  }\r\n}\r\n\r\nfunction Loader (){\r\n  return(<div className=\"loader\">\r\n    <p>TWITCH SURFER</p>\r\n    <p>LOADING</p>\r\n  </div>)\r\n}\r\n\r\nfunction App() {\r\n  const [user, setUser] = useState({ name: \"\", description: \"Select a stream!\" });\r\n  const [streamer_data,setStreamerData] = useState({ valid : false, data: undefined});\r\n  const [current_user,setCurrentUser] = useState(undefined);\r\n  let client_id = \"sh58je5z5mtatvjc7jfc1m6bgfvt94\";\r\n  let redirect_url = \"https://reedkrawiec.github.io/twitchsurfer\";\r\n  let api_url = \"https://twitchsurfer.herokuapp.com\"\r\n  let response_type = \"token+id_token\";\r\n  let scopes = \"openid+user:edit:follows+user:read:email\";\r\n  let claims = JSON.stringify({\r\n    userinfo: {\r\n      email: null,\r\n      email_verified: null,\r\n      picture: null,\r\n      preferred_username: null\r\n    }\r\n  });\r\n  let auth_string = `https://id.twitch.tv/oauth2/authorize?client_id=${client_id}&redirect_uri=${redirect_url}&response_type=${response_type}&scope=${scopes}&claims=${claims}`;\r\n  useEffect(() => {\r\n    if (window.location.hash && !streamer_data.valid) {\r\n      let query_string = window.location.hash.slice(1);\r\n      let raw_auth_data = query_string.split(\"&\").map((x) => x.split(\"=\"));\r\n      let auth_data = {\r\n        access_token: raw_auth_data[0][1],\r\n        id_token: raw_auth_data[1][1],\r\n        scope: raw_auth_data[2][1],\r\n        token_type: raw_auth_data[3][1]\r\n      }\r\n      let d = async () => {\r\n        let x = await twitch_get(\"https://id.twitch.tv/oauth2/userinfo\", auth_data.access_token);\r\n        x = await x.json();\r\n        setCurrentUser(x.preferred_username);\r\n        let y = await fetch(`${api_url}/get_schedule?access=${auth_data.access_token}&id=${x.sub}`);\r\n        y = await y.json();\r\n        let num_of_streamers = y.length;\r\n        console.log(y);\r\n        setStreamerData({valid:true,data: y});\r\n      }\r\n      d();\r\n      \r\n    }\r\n    else{\r\n      let d = async () => {\r\n        let y = await fetch(`${api_url}/get_default`);\r\n        y = await y.json();\r\n        setStreamerData({valid:true,data: y});\r\n      }\r\n      d();\r\n    }\r\n  },[]);\r\n\r\n  return (\r\n    //Setup the App viewport\r\n    <div className=\"loader_holder\">\r\n      <If condition={streamer_data.valid}>\r\n        <StreamerContext.Provider value={streamer_data}>\r\n          <UserContext.Provider value={{ user: user, setUser: setUser }}>\r\n            <div className=\"App\">\r\n              <StreamerInfo auth_string={auth_string} username={current_user} />\r\n              <TimeLineBody />\r\n            </div>\r\n          </UserContext.Provider>\r\n        </StreamerContext.Provider>\r\n      </If>\r\n      <If condition={!streamer_data.valid}>\r\n        <Loader/>\r\n      </If>\r\n    </div>\r\n  )\r\n}\r\n\r\nexport default App;\r\n","// This optional code is used to register a service worker.\r\n// register() is not called by default.\r\n\r\n// This lets the app load faster on subsequent visits in production, and gives\r\n// it offline capabilities. However, it also means that developers (and users)\r\n// will only see deployed updates on subsequent visits to a page, after all the\r\n// existing tabs open on the page have been closed, since previously cached\r\n// resources are updated in the background.\r\n\r\n// To learn more about the benefits of this model and instructions on how to\r\n// opt-in, read https://bit.ly/CRA-PWA\r\n\r\nconst isLocalhost = Boolean(\r\n  window.location.hostname === 'localhost' ||\r\n    // [::1] is the IPv6 localhost address.\r\n    window.location.hostname === '[::1]' ||\r\n    // 127.0.0.0/8 are considered localhost for IPv4.\r\n    window.location.hostname.match(\r\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\r\n    )\r\n);\r\n\r\nexport function register(config) {\r\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\r\n    // The URL constructor is available in all browsers that support SW.\r\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\r\n    if (publicUrl.origin !== window.location.origin) {\r\n      // Our service worker won't work if PUBLIC_URL is on a different origin\r\n      // from what our page is served on. This might happen if a CDN is used to\r\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\r\n      return;\r\n    }\r\n\r\n    window.addEventListener('load', () => {\r\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\r\n\r\n      if (isLocalhost) {\r\n        // This is running on localhost. Let's check if a service worker still exists or not.\r\n        checkValidServiceWorker(swUrl, config);\r\n\r\n        // Add some additional logging to localhost, pointing developers to the\r\n        // service worker/PWA documentation.\r\n        navigator.serviceWorker.ready.then(() => {\r\n          console.log(\r\n            'This web app is being served cache-first by a service ' +\r\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\r\n          );\r\n        });\r\n      } else {\r\n        // Is not localhost. Just register service worker\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction registerValidSW(swUrl, config) {\r\n  navigator.serviceWorker\r\n    .register(swUrl)\r\n    .then(registration => {\r\n      registration.onupdatefound = () => {\r\n        const installingWorker = registration.installing;\r\n        if (installingWorker == null) {\r\n          return;\r\n        }\r\n        installingWorker.onstatechange = () => {\r\n          if (installingWorker.state === 'installed') {\r\n            if (navigator.serviceWorker.controller) {\r\n              // At this point, the updated precached content has been fetched,\r\n              // but the previous service worker will still serve the older\r\n              // content until all client tabs are closed.\r\n              console.log(\r\n                'New content is available and will be used when all ' +\r\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\r\n              );\r\n\r\n              // Execute callback\r\n              if (config && config.onUpdate) {\r\n                config.onUpdate(registration);\r\n              }\r\n            } else {\r\n              // At this point, everything has been precached.\r\n              // It's the perfect time to display a\r\n              // \"Content is cached for offline use.\" message.\r\n              console.log('Content is cached for offline use.');\r\n\r\n              // Execute callback\r\n              if (config && config.onSuccess) {\r\n                config.onSuccess(registration);\r\n              }\r\n            }\r\n          }\r\n        };\r\n      };\r\n    })\r\n    .catch(error => {\r\n      console.error('Error during service worker registration:', error);\r\n    });\r\n}\r\n\r\nfunction checkValidServiceWorker(swUrl, config) {\r\n  // Check if the service worker can be found. If it can't reload the page.\r\n  fetch(swUrl, {\r\n    headers: { 'Service-Worker': 'script' },\r\n  })\r\n    .then(response => {\r\n      // Ensure service worker exists, and that we really are getting a JS file.\r\n      const contentType = response.headers.get('content-type');\r\n      if (\r\n        response.status === 404 ||\r\n        (contentType != null && contentType.indexOf('javascript') === -1)\r\n      ) {\r\n        // No service worker found. Probably a different app. Reload the page.\r\n        navigator.serviceWorker.ready.then(registration => {\r\n          registration.unregister().then(() => {\r\n            window.location.reload();\r\n          });\r\n        });\r\n      } else {\r\n        // Service worker found. Proceed as normal.\r\n        registerValidSW(swUrl, config);\r\n      }\r\n    })\r\n    .catch(() => {\r\n      console.log(\r\n        'No internet connection found. App is running in offline mode.'\r\n      );\r\n    });\r\n}\r\n\r\nexport function unregister() {\r\n  if ('serviceWorker' in navigator) {\r\n    navigator.serviceWorker.ready\r\n      .then(registration => {\r\n        registration.unregister();\r\n      })\r\n      .catch(error => {\r\n        console.error(error.message);\r\n      });\r\n  }\r\n}\r\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './App';\r\nimport * as serviceWorker from './serviceWorker';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister();\r\n"],"sourceRoot":""}